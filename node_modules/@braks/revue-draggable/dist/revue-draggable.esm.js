import { computed, isVue3, ref, watch, watchEffect, getCurrentInstance, defineComponent, h, onUpdated as onUpdated$1 } from 'vue-demi';
import { unrefElement, controlledRef, createEventHook, get, useEventListener, tryOnUnmounted, templateRef, syncRef } from '@vueuse/core';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
function findInArray(array, callback) {
  for (var i = 0, length_1 = array.length; i < length_1; i++) {
    if (callback.apply(callback, [array[i], i, array])) return array[i];
  }
}
function isFunction(func) {
  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
}
function isNum(num) {
  return !isNaN(num);
}

function _int(a) {
  return parseInt(a, 10);
}

var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
function getPrefix(prop) {
  var _a, _b;

  if (prop === void 0) {
    prop = 'transform';
  } // Ensure we're running in an environment where there is actually a global
  // `window` obj


  if (typeof window === 'undefined') return ''; // If we're in a pseudo-browser server-side environment, this access
  // path may not exist, so bail out if it doesn't.

  var style = (_b = (_a = window.document) === null || _a === void 0 ? void 0 : _a.documentElement) === null || _b === void 0 ? void 0 : _b.style;
  if (!style) return '';
  if (prop in style) return '';

  for (var i = 0; i < prefixes.length; i++) {
    if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
  }

  return '';
}
function browserPrefixToKey(prop, prefix) {
  return prefix ? "" + prefix + kebabToTitleCase(prop) : prop;
}

function kebabToTitleCase(str) {
  var out = '';
  var shouldCapitalize = true;

  for (var i = 0; i < str.length; i++) {
    if (shouldCapitalize) {
      out += str[i].toUpperCase();
      shouldCapitalize = false;
    } else if (str[i] === '-') {
      shouldCapitalize = true;
    } else {
      out += str[i];
    }
  }

  return out;
} // Default export is the prefix itself, like 'Moz', 'Webkit', etc
// Note that you may have to re-test for certain things; for instance, Chrome 50
// can handle unprefixed `transform`, but not unprefixed `user-select`


var browserPrefix = getPrefix();

var matchesSelectorFunc = '';
function matchesSelector(el, selector) {
  if (!matchesSelectorFunc) {
    matchesSelectorFunc = findInArray(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {
      // @ts-ignore
      return isFunction(el[method]);
    });
  } // Might not be found entirely (not an Element?) - in that case, bail
  // @ts-ignore


  if (!isFunction(el[matchesSelectorFunc])) return false; // @ts-ignore

  return el[matchesSelectorFunc](selector);
} // Works up the tree to the draggable itself attempting to match selector.

function matchesSelectorAndParentsTo(el, selector, baseNode) {
  var node = el;

  do {
    if (matchesSelector(node, selector)) return true;
    if (node === baseNode) return false;
    node = node.parentNode;
  } while (node);

  return false;
}
function addEvent(el, event, handler, inputOptions) {
  if (!el) return;

  var options = __assign({
    capture: true
  }, inputOptions);

  if (el.addEventListener) {
    el.addEventListener(event, handler, options);
  } else {
    // @ts-ignore
    el['on' + event] = handler;
  }
}
function removeEvent(el, event, handler, inputOptions) {
  if (!el) return;

  var options = __assign({
    capture: true
  }, inputOptions);

  if (el.removeEventListener) {
    el.removeEventListener(event, handler, options);
  } else {
    // @ts-ignore
    el['on' + event] = null;
  }
}
function outerHeight(node) {
  var _a; // This is deliberately excluding margin for our calculations, since we are using
  // offsetTop which is including margin. See getBoundPosition


  var height = node.clientHeight;
  var computedStyle = (_a = node.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getComputedStyle(node);
  height += _int(computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.borderTopWidth);
  height += _int(computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.borderBottomWidth);
  return height;
}
function outerWidth(node) {
  var _a; // This is deliberately excluding margin for our calculations, since we are using
  // offsetLeft which is including margin. See getBoundPosition


  var width = node.clientWidth;
  var computedStyle = (_a = node.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getComputedStyle(node);
  width += _int(computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.borderLeftWidth);
  width += _int(computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.borderRightWidth);
  return width;
}
function getTouch(e, identifier) {
  return e.targetTouches && findInArray(e.targetTouches, function (t) {
    return identifier === t.identifier;
  }) || e.changedTouches && findInArray(e.changedTouches, function (t) {
    return identifier === t.identifier;
  });
}
function getTouchIdentifier(e) {
  if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
  if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
}
function innerHeight(node) {
  var _a;

  var height = node.clientHeight;
  var computedStyle = (_a = node.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getComputedStyle(node);
  height -= _int(computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.paddingTop);
  height -= _int(computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.paddingBottom);
  return height;
}
function innerWidth(node) {
  var _a;

  var width = node.clientWidth;
  var computedStyle = (_a = node.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getComputedStyle(node);
  width -= _int(computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.paddingLeft);
  width -= _int(computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.paddingRight);
  return width;
} // Get from offsetParent

function offsetXYFromParent(evt, offsetParent, scale) {
  var isBody = offsetParent === offsetParent.ownerDocument.body;
  var offsetParentRect = isBody ? {
    left: 0,
    top: 0
  } : offsetParent.getBoundingClientRect();
  var x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
  var y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
  return {
    x: x,
    y: y
  };
}
function createCSSTransform(controlPos, positionOffset) {
  var _a;

  var translation = getTranslation(controlPos, 'px', positionOffset);
  return _a = {}, _a[browserPrefixToKey('transform', browserPrefix)] = translation, _a;
}
function createSVGTransform(controlPos, positionOffset) {
  return getTranslation(controlPos, '', positionOffset);
}
function getTranslation(_a, unitSuffix, positionOffset) {
  var x = _a.x,
      y = _a.y;

  if (unitSuffix === void 0) {
    unitSuffix = 'px';
  }

  var translation = "translate(" + x + unitSuffix + "," + y + unitSuffix + ")";

  if (positionOffset) {
    var defaultX = "" + (typeof positionOffset.x === 'string' ? positionOffset.x : positionOffset.x + unitSuffix);
    var defaultY = "" + (typeof positionOffset.y === 'string' ? positionOffset.y : positionOffset.y + unitSuffix);
    translation = "translate(" + defaultX + ", " + defaultY + ")" + translation;
  }

  return translation;
}
function addUserSelectStyles(doc) {
  if (!doc) return;
  var styleEl = doc.getElementById('revue-draggable-style-el');

  if (!styleEl) {
    styleEl = doc.createElement('style');
    styleEl.type = 'text/css';
    styleEl.id = 'revue-draggable-style-el';
    styleEl.innerHTML = '.revue-draggable-transparent-selection *::-moz-selection {all: inherit;}\n';
    styleEl.innerHTML += '.revue-draggable-transparent-selection *::selection {all: inherit;}\n';
    doc.getElementsByTagName('head')[0].appendChild(styleEl);
  }

  if (doc.body) addClassName(doc.body, 'revue-draggable-transparent-selection');
}
function removeUserSelectStyles(doc) {
  if (!doc) return;

  try {
    if (doc.body) removeClassName(doc.body, 'revue-draggable-transparent-selection');
    var selection = (doc.defaultView || window).getSelection();

    if (selection && selection.type !== 'Caret') {
      selection.removeAllRanges();
    }
  } catch (e) {// probably IE
  }
}
function addClassName(el, className) {
  if (el.classList) {
    el.classList.add(className);
  } else {
    if (!el.className.match(new RegExp("(?:^|\\s)" + className + "(?!\\S)"))) {
      el.className += " " + className;
    }
  }
}
function removeClassName(el, className) {
  if (el.classList) {
    el.classList.remove(className);
  } else {
    el.className = el.className.replace(new RegExp("(?:^|\\s)" + className + "(?!\\S)", 'g'), '');
  }
}

function getBoundPosition(_a) {
  var bounds = _a.bounds,
      x = _a.x,
      y = _a.y,
      node = _a.node; // If no bounds, short-circuit and move on

  if (!bounds) return [x, y]; // Clone new bounds

  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);

  if (typeof bounds === 'string') {
    var ownerDocument = node.ownerDocument;
    var ownerWindow = ownerDocument.defaultView;
    var boundNode = bounds === 'parent' ? node.parentNode : ownerDocument.querySelector(bounds);

    if (!(ownerWindow && boundNode instanceof ownerWindow.HTMLElement)) {
      throw new Error('Bounds selector "' + bounds + '" could not find an element.');
    }

    var nodeStyle = ownerWindow.getComputedStyle(node);
    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode); // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.

    bounds = {
      left: -(node.offsetLeft - boundNode.offsetLeft) + _int(boundNodeStyle.paddingLeft) + _int(nodeStyle.marginLeft),
      top: -(node.offsetTop - boundNode.offsetTop) + _int(boundNodeStyle.paddingTop) + _int(nodeStyle.marginTop),
      right: innerWidth(boundNode) - outerWidth(node) - node.offsetLeft + _int(boundNodeStyle.paddingRight) - _int(nodeStyle.marginRight),
      bottom: innerHeight(boundNode) - outerHeight(node) - node.offsetTop + _int(boundNodeStyle.paddingBottom) - _int(nodeStyle.marginBottom)
    };
  } // Keep x and y below right and bottom limits...


  if (isNum(bounds.right)) x = Math.min(x, bounds.right);
  if (isNum(bounds.bottom)) y = Math.min(y, bounds.bottom); // But above left and top limits.

  if (isNum(bounds.left)) x = Math.max(x, bounds.left);
  if (isNum(bounds.top)) y = Math.max(y, bounds.top);
  return [x, y];
}
function snapToGrid(grid, pendingX, pendingY) {
  var x = Math.round(pendingX / grid[0]) * grid[0];
  var y = Math.round(pendingY / grid[1]) * grid[1];
  return [x, y];
}
function canDragX(axis) {
  return axis === 'both' || axis === 'x';
}
function canDragY(axis) {
  return axis === 'both' || axis === 'y';
}
function getControlPosition(_a) {
  var e = _a.e,
      touch = _a.touch,
      node = _a.node,
      offsetContainer = _a.offsetContainer,
      scale = _a.scale;
  var touchObj = typeof touch === 'number' ? getTouch(e, touch) : null;
  if (typeof touch === 'number' && !touchObj) return null; // not the right touch

  var offsetParent = offsetContainer || node.offsetParent || node.ownerDocument.body;
  return offsetXYFromParent(touchObj || e, offsetParent, scale);
}
function createCoreData(_a) {
  var node = _a.node,
      x = _a.x,
      y = _a.y,
      lastX = _a.lastX,
      lastY = _a.lastY;
  var isStart = !isNaN(lastX);

  if (!isStart) {
    // If this is our first move, use the x and y as last coords.
    return {
      node: node,
      deltaX: 0,
      deltaY: 0,
      lastX: x,
      lastY: y,
      x: x,
      y: y
    };
  } else {
    // Otherwise calculate proper values.
    return {
      node: node,
      deltaX: x - lastX,
      deltaY: y - lastY,
      lastX: lastX,
      lastY: lastY,
      x: x,
      y: y
    };
  }
}
function createDraggableData(_a) {
  var scale = _a.scale,
      x = _a.x,
      y = _a.y,
      data = _a.data;
  return {
    node: data.node,
    x: x + data.deltaX / scale,
    y: y + data.deltaY / scale,
    deltaX: data.deltaX / scale,
    deltaY: data.deltaY / scale,
    lastX: x,
    lastY: y
  };
}

function cloneBounds(bounds) {
  return {
    left: bounds.left,
    top: bounds.top,
    right: bounds.right,
    bottom: bounds.bottom
  };
}

function log() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  if (typeof process !== 'undefined' && process.env.DRAGGABLE_DEBUG) console.log.apply(console, args);
}

var es6 = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }


    if ((a instanceof Map) && (b instanceof Map)) {
      if (a.size !== b.size) return false;
      for (i of a.entries())
        if (!b.has(i[0])) return false;
      for (i of a.entries())
        if (!equal(i[1], b.get(i[0]))) return false;
      return true;
    }

    if ((a instanceof Set) && (b instanceof Set)) {
      if (a.size !== b.size) return false;
      for (i of a.entries())
        if (!b.has(i[0])) return false;
      return true;
    }

    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (a[i] !== b[i]) return false;
      return true;
    }


    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

var eventsFor = {
  touch: {
    start: 'touchstart',
    move: 'touchmove',
    stop: 'touchend'
  },
  mouse: {
    start: 'mousedown',
    move: 'mousemove',
    stop: 'mouseup'
  }
}; // Default to mouse events.

var dragEventFor = eventsFor.mouse;

var useDraggableCore = function useDraggableCore(target, options) {
  if (!target) {
    console.warn('You are trying to use <DraggableCore> without passing a valid node reference. This will cause errors down the line.');
  }

  var stateObj = Object.assign({
    enableUserSelectHack: true,
    allowAnyClick: true,
    disabled: false,
    offsetParent: undefined,
    grid: undefined,
    handle: '',
    cancel: '',
    dragged: false,
    update: true,
    slackX: 0,
    slackY: 0,
    scale: 1,
    dragging: false,
    x: 0,
    y: 0,
    touch: 0,
    isElementSVG: false,
    prevPropsPosition: {
      x: 0,
      y: 0
    },
    start: function start() {},
    move: function move() {},
    stop: function stop() {}
  }, options);
  var node = computed(function () {
    return unrefElement(target);
  });
  var state;

  if (isVue3) {
    state = controlledRef(stateObj, {
      onBeforeChange: function onBeforeChange(val, oldVal) {
        if (es6(val, oldVal)) {
          return;
        }
      },
      onChanged: function onChanged(val) {
        init();
        onUpdateHook.trigger(val);
      }
    });
  } else {
    state = ref(stateObj);
    watch(state, function (val, oldVal) {
      if (es6(val, oldVal)) {
        return;
      }

      init();
      onUpdateHook.trigger(val);
    });
  }

  var onDragStartHook = createEventHook(),
      onDragHook = createEventHook(),
      onDragStopHook = createEventHook(),
      onUpdateHook = createEventHook();

  var handleDragStart = function handleDragStart(e) {
    var _a, _b;

    if (!get(state).allowAnyClick && e.button !== 0) return false;

    if (!get(node) || !get(node).ownerDocument || !get(node).ownerDocument.body) {
      throw new Error('No ref element found on DragStart!');
    }

    var ownerDocument = get(node).ownerDocument;

    if (get(state).disabled || !(ownerDocument.defaultView && e.target instanceof ownerDocument.defaultView.Node) || get(state).handle && !matchesSelectorAndParentsTo(e.target, get(state).handle, get(node)) || get(state).cancel && matchesSelectorAndParentsTo(e.target, get(state).cancel, get(node))) {
      return;
    }

    var isTouch = e.type === 'touchstart';
    if (isTouch) e.preventDefault();
    get(state).touch = getTouchIdentifier(e);
    var position = getControlPosition({
      e: e,
      touch: get(state).touch,
      node: get(node),
      offsetContainer: get(state).offsetParent,
      scale: get(state).scale
    });
    if (position == null) return;
    var x = position.x,
        y = position.y;
    var coreEvent = createCoreData({
      node: get(node),
      x: x,
      y: y,
      lastX: get(state).x,
      lastY: get(state).y
    });
    log('DraggableCore: handleDragStart: %j', coreEvent);
    var shouldUpdate = (_b = (_a = get(state)).start) === null || _b === void 0 ? void 0 : _b.call(_a, e, coreEvent);
    onDragStartHook.trigger({
      event: e,
      data: coreEvent
    });
    if ((shouldUpdate || get(state).update) === false) return false;
    if (get(state).enableUserSelectHack) addUserSelectStyles(ownerDocument);
    get(state).dragging = true;
    get(state).x = x;
    get(state).y = y;
    addEvent(ownerDocument, dragEventFor.move, handleDrag);
    addEvent(ownerDocument, dragEventFor.stop, handleDragStop);
  };

  var handleDrag = function handleDrag(e) {
    var _a;

    var _b, _c;

    if (get(node)) {
      var position = getControlPosition({
        e: e,
        touch: get(state).touch,
        node: get(node),
        offsetContainer: get(state).offsetParent,
        scale: get(state).scale
      });
      if (position == null) return;
      var x = position.x,
          y = position.y; // Snap to grid if prop has been provided

      if (Array.isArray(get(state).grid)) {
        var deltaX = x - get(state).x,
            deltaY = y - get(state).y;
        _a = snapToGrid(get(state).grid, deltaX, deltaY), deltaX = _a[0], deltaY = _a[1];
        if (!deltaX && !deltaY) return;
        x = get(state).x + deltaX;
        y = get(state).y + deltaY;
      }

      var coreEvent = createCoreData({
        node: get(node),
        x: x,
        y: y,
        lastX: get(state).x,
        lastY: get(state).y
      });
      log('DraggableCore: handleDrag: %j', coreEvent);
      var shouldUpdate = (_c = (_b = get(state)).move) === null || _c === void 0 ? void 0 : _c.call(_b, e, coreEvent);
      onDragHook.trigger({
        event: e,
        data: coreEvent
      });

      if ((shouldUpdate || get(state).update) === false) {
        try {
          handleDragStop(new MouseEvent('mouseup'));
        } catch (err) {
          // Old browsers
          var event_1 = document.createEvent('MouseEvents'); // I see why this insanity was deprecated

          event_1.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
          handleDragStop(event_1);
        }

        return;
      }

      get(state).x = x;
      get(state).y = y;
    }
  };

  var handleDragStop = function handleDragStop(e) {
    var _a, _b;

    if (!get(state).dragging) return;

    if (get(node)) {
      var position = getControlPosition({
        e: e,
        touch: get(state).touch,
        node: get(node),
        offsetContainer: get(state).offsetParent,
        scale: get(state).scale
      });
      if (position == null) return;
      var x = position.x,
          y = position.y;
      var coreEvent = createCoreData({
        node: get(node),
        x: x,
        y: y,
        lastX: get(state).x,
        lastY: get(state).y
      });
      var shouldUpdate = (_b = (_a = get(state)).stop) === null || _b === void 0 ? void 0 : _b.call(_a, e, coreEvent);
      onDragStopHook.trigger({
        event: e,
        data: coreEvent
      });
      if ((shouldUpdate || get(state).update) === false) return false;
      if (get(state).enableUserSelectHack) removeUserSelectStyles(get(node).ownerDocument);
      log('DraggableCore: handleDragStop: %j', coreEvent);
      get(state).dragging = false;
      log('DraggableCore: Removing handlers');
      removeEvent(get(node).ownerDocument, dragEventFor.move, handleDrag);
      removeEvent(get(node).ownerDocument, dragEventFor.stop, handleDragStop);
    }
  };

  var onMouseDown = function onMouseDown(e) {
    dragEventFor = eventsFor.mouse;
    if (e.which == 3) return;
    return handleDragStart(e);
  };

  var onMouseUp = function onMouseUp(e) {
    dragEventFor = eventsFor.mouse;
    return handleDragStop(e);
  };

  var onTouchStart = function onTouchStart(e) {
    dragEventFor = eventsFor.touch;
    return handleDragStart(e);
  };

  var onTouchEnd = function onTouchEnd(e) {
    dragEventFor = eventsFor.touch;
    return handleDragStop(e);
  };

  var initialized = false;

  var init = function init() {
    if (get(node) && !initialized) {
      initialized = true;
      useEventListener(get(node), eventsFor.touch.start, onTouchStart, {
        passive: false
      });
      useEventListener(get(node), eventsFor.touch.stop, onTouchEnd);
      useEventListener(get(node), eventsFor.mouse.start, onMouseDown);
      useEventListener(get(node), eventsFor.mouse.stop, onMouseUp);
    }
  };

  watchEffect(function () {
    init();
  }, {
    flush: 'post'
  });
  return {
    state: state,
    onUpdated: onUpdateHook.on,
    onDragStart: onDragStartHook.on,
    onDrag: onDragHook.on,
    onDragStop: onDragStopHook.on
  };
};

var useDraggable = function useDraggable(target, options) {
  if (!target) {
    console.warn('You are trying to use <Draggable> without passing a valid target reference.');
  }

  var stateObj = Object.assign({
    allowAnyClick: true,
    cancel: '',
    handle: '',
    disabled: false,
    enableUserSelectHack: true,
    offsetParent: undefined,
    grid: undefined,
    start: function start() {},
    move: function move() {},
    stop: function stop() {},
    position: undefined,
    positionOffset: undefined,
    scale: 1,
    axis: 'both',
    defaultClassNameDragging: 'revue-draggable-dragging',
    defaultClassNameDragged: 'revue-draggable-dragged',
    defaultClassName: 'revue-draggable',
    defaultPosition: {
      x: 0,
      y: 0
    },
    bounds: false,
    dragging: false,
    dragged: false,
    x: 0,
    y: 0,
    prevPropsPosition: {
      x: 0,
      y: 0
    },
    slackX: 0,
    slackY: 0,
    isElementSVG: false,
    update: true
  }, options);
  var node = computed(function () {
    return unrefElement(target);
  });
  var state;

  if (isVue3) {
    state = controlledRef(stateObj, {
      onBeforeChange: function onBeforeChange(val, oldVal) {
        if (es6(val, oldVal)) {
          return;
        }

        coreState.value = __assign(__assign({}, coreState.value), val);
      },
      onChanged: function onChanged(val) {
        onUpdated();
        onUpdateHook.trigger(val);
      }
    });
  } else {
    state = ref(stateObj);
    watch(state, function (val, oldVal) {
      if (es6(val, oldVal)) {
        return;
      }

      coreState.value = __assign(__assign({}, coreState.value), val);
      onUpdated();
      onUpdateHook.trigger(val);
    });
  }

  var onDragStartHook = createEventHook(),
      onDragHook = createEventHook(),
      onDragStopHook = createEventHook(),
      onTransformedHook = createEventHook(),
      onUpdateHook = createEventHook();

  var onDragStart = function onDragStart(e, data) {
    var _a, _b;

    log('Draggable: onDragStart: %j', data);
    var uiData = createDraggableData({
      data: data,
      x: get(state).x,
      y: get(state).y,
      scale: get(state).scale
    });
    var shouldUpdate = (_b = (_a = get(state)).start) === null || _b === void 0 ? void 0 : _b.call(_a, e, uiData);
    onDragStartHook.trigger({
      event: e,
      data: uiData
    });
    if ((shouldUpdate || get(state).update) === false) return false;
    get(state).dragging = true;
    get(state).dragged = true;
    transform();
  };

  var onDrag = function onDrag(e, data) {
    var _a, _b;

    if (!get(state).dragging) return false;
    log('Draggable: onDrag: %j', data);
    var uiData = createDraggableData({
      data: data,
      x: get(state).x,
      y: get(state).y,
      scale: get(state).scale
    });
    var newState = {
      x: uiData.x,
      y: uiData.y,
      slackX: NaN,
      slackY: NaN
    };

    if (get(state).bounds) {
      var x = newState.x,
          y = newState.y;
      newState.x += get(state).slackX;
      newState.y += get(state).slackY;

      var _c = getBoundPosition({
        bounds: get(state).bounds,
        x: newState.x,
        y: newState.y,
        node: data.node
      }),
          boundX = _c[0],
          boundY = _c[1];

      newState.x = boundX;
      newState.y = boundY;
      newState.slackX = get(state).slackX + (x - newState.x);
      newState.slackY = get(state).slackY + (y - newState.y);
      uiData.x = newState.x;
      uiData.y = newState.y;
      uiData.deltaX = newState.x - get(state).x;
      uiData.deltaY = newState.y - get(state).y;
    }

    var shouldUpdate = (_b = (_a = get(state)).move) === null || _b === void 0 ? void 0 : _b.call(_a, e, uiData);
    onDragHook.trigger({
      event: e,
      data: uiData
    });
    if ((shouldUpdate || get(state).update) === false) return false;
    get(state).x = newState.x;
    get(state).y = newState.y;
    if (newState.slackX) get(state).slackX = newState.slackX;
    if (newState.slackY) get(state).slackY = newState.slackY;
    transform();
  };

  var onDragStop = function onDragStop(e, data) {
    var _a, _b;

    if (!get(state).dragging) return false;
    var uiData = createDraggableData({
      scale: get(state).scale,
      x: get(state).x,
      y: get(state).y,
      data: data
    });
    var shouldUpdate = (_b = (_a = get(state)).stop) === null || _b === void 0 ? void 0 : _b.call(_a, e, uiData);
    onDragStopHook.trigger({
      event: e,
      data: uiData
    });
    if ((shouldUpdate || get(state).update) === false) return false;
    log('Draggable: onDragStop: %j', data);
    var pos = get(state).position;
    var controlled = Boolean(pos);

    if (controlled && pos) {
      get(state).x = pos.x;
      get(state).y = pos.y;
    }

    get(state).dragging = false;
    get(state).slackX = 0;
    get(state).slackY = 0;
    transform();
  };

  var transform = function transform() {
    var _a;

    if (!get(node) || get(state).update === false) return; // If this is controlled, we don't want to move it - unless it's dragging.

    var controlled = Boolean(get(state).position);
    var canDrag = !controlled || get(state).dragging;
    var validPosition = get(state).position || get(state).defaultPosition;

    var transformOpts = function transformOpts() {
      return {
        // Set left if horizontal drag is enabled
        x: canDragX(get(state).axis) && canDrag ? get(state).x : validPosition.x,
        // Set top if vertical drag is enabled
        y: canDragY(get(state).axis) && canDrag ? get(state).y : validPosition.y
      };
    };

    var offset = get(state).positionOffset;
    var isSvg = get(state).isElementSVG;
    var styles = !isSvg && createCSSTransform(transformOpts(), offset) || false;
    var svgTransform = isSvg && createSVGTransform(transformOpts(), offset) || false;
    var classes = (_a = {}, _a[get(state).defaultClassName] = !get(state).disabled, _a[get(state).defaultClassNameDragging] = get(state).dragging, _a[get(state).defaultClassNameDragged] = get(state).dragged, _a);

    if (typeof svgTransform === 'string') {
      get(node).setAttribute('transform', svgTransform);
    }

    Object.keys(styles).forEach(function (style) {
      if (styles) get(node).style[style] = styles[style];
    });
    Object.keys(classes).forEach(function (cl) {
      classes[cl] ? get(node).classList.toggle(cl, true) : get(node).classList.toggle(cl, false);
    });
    var transformedData = {
      el: get(node),
      style: styles,
      transform: svgTransform,
      classes: classes
    };
    onTransformedHook.trigger(transformedData);
  };

  var onUpdated = function onUpdated() {
    var pos = get(state).position;

    if (pos && (!get(state).prevPropsPosition || pos.x !== get(state).prevPropsPosition.x || pos.y !== get(state).prevPropsPosition.y)) {
      log('Draggable: Updated %j', {
        position: get(state).prevPropsPosition,
        prevPropsPosition: get(state).prevPropsPosition
      });
      get(state).x = pos.x;
      get(state).y = pos.y;
      get(state).prevPropsPosition = __assign({}, pos);
    }

    transform();
  };

  tryOnUnmounted(function () {
    get(state).dragging = false;
  });

  var _a = useDraggableCore(target, options),
      coreStart = _a.onDragStart,
      coreDrag = _a.onDrag,
      coreStop = _a.onDragStop,
      coreState = _a.state;

  coreDrag(function (_a) {
    var event = _a.event,
        data = _a.data;
    onDrag(event, data);
  });
  coreStart(function (_a) {
    var event = _a.event,
        data = _a.data;
    onDragStart(event, data);
  });
  coreStop(function (_a) {
    var event = _a.event,
        data = _a.data;
    onDragStop(event, data);
  });
  watchEffect(function () {
    transform();
  }, {
    flush: 'post'
  });
  return {
    state: state,
    onUpdated: onUpdateHook.on,
    onDragStart: onDragStartHook.on,
    onDrag: onDragHook.on,
    onDragStop: onDragStopHook.on,
    onTransformed: onTransformedHook.on
  };
};

var _a;

var onMounted = function onMounted(el, binding) {
  var _a;

  var instance = getCurrentInstance();
  var emit = (_a = instance === null || instance === void 0 ? void 0 : instance.emit) !== null && _a !== void 0 ? _a : function (arg, data) {
    var event = new CustomEvent(arg, {
      detail: data
    });
    el.dispatchEvent(event);
  }; // sort of hacky but we don't want the directive to create multiple instances of the composable and thus apply multiple event listeners etc.

  if (binding.arg === 'core') {
    var _b = useDraggableCore(el, __assign({}, binding.value)),
        onDrag = _b.onDrag,
        onDragStop = _b.onDragStop,
        onDragStart = _b.onDragStart,
        state = _b.state;

    onDrag(function (dragEvent) {
      emit('move', dragEvent);
    });
    onDragStart(function (dragStartEvent) {
      emit('start', dragStartEvent);
    });
    onDragStop(function (dragStopEvent) {
      emit('stop', dragStopEvent);
    }); // @ts-ignore

    el['revue-draggable'] = state;
  } else {
    var _c = useDraggable(el, __assign({}, binding.value)),
        onDrag = _c.onDrag,
        onDragStop = _c.onDragStop,
        onDragStart = _c.onDragStart,
        onTransformed = _c.onTransformed,
        state = _c.state;

    onDrag(function (dragEvent) {
      emit('move', dragEvent);
    });
    onDragStart(function (dragStartEvent) {
      emit('start', dragStartEvent);
    });
    onDragStop(function (dragStopEvent) {
      emit('stop', dragStopEvent);
    });
    onTransformed(function (transformEvent) {
      emit('transformed', transformEvent);
    }); // @ts-ignore

    el['revue-draggable'] = state;
  }
};

var onUpdated = function onUpdated(el, binding) {
  // typehack as we store the draggable instance on the element, see the comment above
  var element = el;

  if (typeof element['revue-draggable'] !== 'undefined' && binding.value) {
    var state = element['revue-draggable'];

    var updatedState = __assign(__assign({}, state.value), binding.value);

    if (es6(state.value, updatedState)) return;
    state.value = updatedState;
  }
};

var DraggableDirective = (_a = {}, _a[isVue3 ? 'mounted' : 'inserted'] = onMounted, _a[isVue3 ? 'beforeUpdate' : 'update'] = onUpdated, _a);

var Draggable = defineComponent({
  name: 'Draggable',
  props: {
    axis: {
      type: String,
      "default": 'both'
    },
    bounds: {
      type: [Object, String, Boolean],
      "default": false
    },
    defaultClassName: {
      type: String,
      "default": 'revue-draggable'
    },
    defaultClassNameDragging: {
      type: String,
      "default": 'revue-draggable-dragging'
    },
    defaultClassNameDragged: {
      type: String,
      "default": 'revue-draggable-dragged'
    },
    defaultPosition: {
      type: Object,
      "default": function _default() {
        return {
          x: 0,
          y: 0
        };
      }
    },
    scale: {
      type: Number,
      "default": 1
    },
    position: {
      type: Object,
      "default": undefined
    },
    positionOffset: {
      type: Object,
      "default": undefined
    },
    allowAnyClick: {
      type: Boolean,
      "default": true
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    enableUserSelectHack: {
      type: Boolean,
      "default": true
    },
    cancel: {
      type: String,
      "default": undefined
    },
    offsetParent: {
      type: Object,
      "default": function _default() {}
    },
    grid: {
      type: Array,
      "default": undefined
    },
    handle: {
      type: String,
      "default": undefined
    },
    update: {
      type: Boolean,
      "default": true
    },
    start: {
      type: Function,
      "default": function _default() {}
    },
    move: {
      type: Function,
      "default": function _default() {}
    },
    stop: {
      type: Function,
      "default": function _default() {}
    }
  },
  emits: ['move', 'start', 'stop', 'transformed'],
  setup: function setup(props, _a) {
    var slots = _a.slots,
        emit = _a.emit,
        attrs = _a.attrs;
    var draggableState = ref();

    var init = function init(target) {
      var _a = useDraggable(target, props),
          onDrag = _a.onDrag,
          onDragStart = _a.onDragStart,
          onDragStop = _a.onDragStop,
          onTransformed = _a.onTransformed,
          state = _a.state;

      syncRef(state, draggableState);
      onDrag(function (dragEvent) {
        emit('move', dragEvent);
      });
      onDragStart(function (dragStartEvent) {
        emit('start', dragStartEvent);
      });
      onDragStop(function (dragStopEvent) {
        emit('stop', dragStopEvent);
      });
      onTransformed(function (transformEvent) {
        emit('transformed', transformEvent);
      });
      onUpdated$1(function () {
        state.value = __assign(__assign({}, state.value), props);
      });
    };

    var target = templateRef('target', null);
    init(target);

    if (isVue3) {
      return function () {
        if (slots["default"]) {
          return h(slots["default"]()[0], __assign({
            ref: 'target'
          }, attrs), {});
        }
      };
    } else {
      return function () {
        if (slots["default"]) {
          return h('div', __assign({
            ref: 'target'
          }, attrs), slots["default"]());
        }
      };
    }
  }
});

var DraggableCore = defineComponent({
  name: 'DraggableCore',
  props: {
    scale: {
      type: Number,
      "default": 1
    },
    allowAnyClick: {
      type: Boolean,
      "default": true
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    enableUserSelectHack: {
      type: Boolean,
      "default": true
    },
    cancel: {
      type: String,
      "default": undefined
    },
    offsetParent: {
      type: Object,
      "default": undefined
    },
    grid: {
      type: Array,
      "default": undefined
    },
    handle: {
      type: String,
      "default": undefined
    },
    start: {
      type: Function,
      "default": function _default() {}
    },
    move: {
      type: Function,
      "default": function _default() {}
    },
    stop: {
      type: Function,
      "default": function _default() {}
    }
  },
  emits: ['start', 'move', 'stop'],
  setup: function setup(props, _a) {
    var slots = _a.slots,
        emit = _a.emit,
        attrs = _a.attrs;
    var target = templateRef('core-target', null);

    var _b = useDraggableCore(target, props),
        onDrag = _b.onDrag,
        onDragStart = _b.onDragStart,
        onDragStop = _b.onDragStop,
        state = _b.state;

    onDrag(function (dragEvent) {
      emit('move', dragEvent);
    });
    onDragStart(function (dragStartEvent) {
      emit('start', dragStartEvent);
    });
    onDragStop(function (dragStopEvent) {
      emit('stop', dragStopEvent);
    });
    onUpdated$1(function () {
      state.value = __assign(__assign({}, state.value), props);
    });

    if (isVue3) {
      return function () {
        if (slots["default"]) {
          return h(slots["default"]()[0], __assign({
            ref: 'core-target'
          }, attrs), {});
        }
      };
    } else {
      return function () {
        if (slots["default"]) {
          return h('div', __assign({
            ref: 'core-target'
          }, attrs), slots["default"]());
        }
      };
    }
  }
});

var plugin = function plugin(app) {
  app.component('Draggable', Draggable);
  app.component('DraggableCore', DraggableCore);
  app.directive('draggable', DraggableDirective);
};

export { Draggable, DraggableCore, DraggableDirective, plugin as DraggablePlugin, useDraggable, useDraggableCore };
